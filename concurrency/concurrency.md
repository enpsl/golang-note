# 并发基础

## 1. 概念

并发意味着程序在运行时有多个执行上下文，对应多个调用栈。

并发与并行的区别：

并发的主流实现模型：

| 实现模型          | 说明                       | 特点                      |
| ------------- | ------------------------ | ----------------------- |
| 多进程           | 操作系统层面的并发模式              | 处理简单，互不影响，但开销大          |
| 多线程           | 系统层面的并发模式                | 有效，开销较大，高并发时影响效率        |
| 基于回调的非阻塞/异步IO | 多用于高并发服务器开发中             | 编程复杂，开销小                |
| 协程            | 用户态线程，不需要操作系统抢占调度，寄存于线程中 | 编程简单，结构简单，开销极小，但需要语言的支持 |

共享内存系统：线程之间采用共享内存的方式通信，通过加锁来避免死锁或资源竞争。

消息传递系统：将线程间共享状态封装在消息中，通过发送消息来共享内存，而非通过共享内存来通信。

## 2. 协程

执行体是个抽象的概念，在操作系统中分为三个级别：进程（process），进程内的线程（thread），进程内的协程（coroutine，轻量级线程）。协程的数量级可达到上百万个，进程和线程的数量级最多不超过一万个。Go语言中的协程叫goroutine，Go标准库提供的调用操作，IO操作都会出让CPU给其他goroutine，让协程间的切换管理不依赖系统的线程和进程，不依赖CPU的核心数量。

## 3. 并发通信

并发编程的难度在于协调，协调需要通过通信，并发通信模型分为共享数据和消息。共享数据即多个并发单元保持对同一个数据的引用，数据可以是内存数据块，磁盘文件，网络数据等。数据共享通过加锁的方式来避免死锁和资源竞争。Go语言则采取消息机制来通信，每个并发单元是独立的个体，有独立的变量，不同并发单元间这些变量不共享，每个并发单元的输入输出只通过消息的方式。
